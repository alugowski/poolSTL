// Copyright (C) 2023 Adam Lugowski. All rights reserved.
// Use of this source code is governed by:
// the BSD 2-clause license, the MIT license, or at your choosing the BSL-1.0 license found in the LICENSE.*.txt files.
// SPDX-License-Identifier: BSD-2-Clause OR MIT OR BSL-1.0


#ifndef POOLSTL_EXECUTION_HPP
#define POOLSTL_EXECUTION_HPP

#include <memory>
#include <mutex>
#include <type_traits>

#include "internal/task_thread_pool.hpp"
#include "internal/utils.hpp"

#if POOLSTL_HAVE_CXX17
#include <variant>
#endif

namespace poolstl {

    namespace ttp = task_thread_pool;

    namespace execution {
        namespace internal {
            /**
             * Holds the thread pool used by par.
             */
            inline std::shared_ptr<ttp::task_thread_pool> get_default_pool() {
                static std::shared_ptr<ttp::task_thread_pool> pool;
                static std::once_flag flag;
                std::call_once(flag, [&](){ pool = std::make_shared<ttp::task_thread_pool>(); });
                return pool;
            }
        }

        /**
         * Base class for all poolSTL policies.
         */
        struct poolstl_policy {};

        /**
         * A sequential policy that simply forwards to the non-policy overload.
         */
        struct sequenced_policy : public poolstl_policy {
            POOLSTL_NO_DISCARD ttp::task_thread_pool* pool() const {
                // never called
                return nullptr;
            }

            POOLSTL_NO_DISCARD bool par_allowed() const {
                return false;
            }
        };

        /**
         * A parallel policy that can use a user-specified thread pool or a default one.
         */
        struct parallel_policy : public poolstl_policy {
            parallel_policy() = default;
            explicit parallel_policy(ttp::task_thread_pool* on_pool, bool par_ok): on_pool(on_pool), par_ok(par_ok) {}

            parallel_policy on(ttp::task_thread_pool& pool) const {
                return parallel_policy{&pool, par_ok};
            }

            parallel_policy par_if(bool call_par) const {
                return parallel_policy{on_pool, call_par};
            }

            POOLSTL_NO_DISCARD ttp::task_thread_pool* pool() const {
                if (on_pool) {
                    return on_pool;
                } else {
                    return internal::get_default_pool().get();
                }
            }

            POOLSTL_NO_DISCARD bool par_allowed() const {
                return par_ok;
            }

        protected:
            ttp::task_thread_pool *on_pool = nullptr;
            bool par_ok = true;
        };

        constexpr sequenced_policy seq{};
        constexpr parallel_policy par{};


#if POOLSTL_HAVE_CXX17
        /**
         * A policy that allows selecting a policy at runtime.
         *
         * @tparam Variant std::variant<> of policy options.
         */
        template <typename Variant>
        struct variant_policy {
            explicit variant_policy(const Variant& policy): var(policy) {}
            Variant var;
        };

        namespace internal {
            using poolstl_policy_variant = std::variant<
                poolstl::execution::parallel_policy,
                poolstl::execution::sequenced_policy>;
        }

#endif

        /**
         * Choose parallel or sequential at runtime.
         *
         * @param call_par Whether to use a parallel policy.
         * @return `par` if call_par is true, else `seq`.
         */
        inline parallel_policy par_if(bool call_par) {
            return parallel_policy{nullptr, call_par};
        }

        /**
         * Choose parallel or sequential at runtime, with pool selection.
         *
         * @param call_par Whether to use a parallel policy.
         * @return `par.on(pool)` if call_par is true, else `seq`.
         */
        inline parallel_policy par_if(bool call_par, ttp::task_thread_pool& pool) {
            return parallel_policy{&pool, call_par};
        }
    }

    using execution::seq;
    using execution::par;
    using execution::par_if;
#if POOLSTL_HAVE_CXX17
    using execution::variant_policy;
#endif

    namespace internal {
        /**
         * To enable/disable seq overload resolution
         */
        template <class ExecPolicy, class Tp>
        using enable_if_seq =
            typename std::enable_if<
                std::is_same<poolstl::execution::sequenced_policy,
                    typename std::remove_cv<typename std::remove_reference<ExecPolicy>::type>::type>::value,
                Tp>::type;

        /**
         * To enable/disable par overload resolution
         */
        template <class ExecPolicy, class Tp>
        using enable_if_par =
            typename std::enable_if<
                std::is_same<poolstl::execution::parallel_policy,
                    typename std::remove_cv<typename std::remove_reference<ExecPolicy>::type>::type>::value,
                Tp>::type;

        /**
         * To enable/disable par overload resolution
         */
        template <class ExecPolicy, class Tp>
        using enable_if_poolstl_policy =
            typename std::enable_if<
                std::is_base_of<poolstl::execution::poolstl_policy,
                    typename std::remove_cv<typename std::remove_reference<ExecPolicy>::type>::type>::value,
                Tp>::type;

        template <class ExecPolicy>
        bool is_seq(const ExecPolicy& policy) {
            return !policy.par_allowed();
        }

#if POOLSTL_HAVE_CXX17
        /**
         * Helper for enable_if_poolstl_variant
         */
        template <typename T> struct is_poolstl_variant_policy : std::false_type {};
        template <typename V> struct is_poolstl_variant_policy<
            ::poolstl::execution::variant_policy<V>> :std::true_type {};

        /**
         * To enable/disable variant_policy (for par_if) overload resolution
         */
        template <class ExecPolicy, class Tp>
        using enable_if_poolstl_variant =
            typename std::enable_if<
                is_poolstl_variant_policy<
                    typename std::remove_cv<typename std::remove_reference<ExecPolicy>::type>::type>::value,
                Tp>::type;
#endif
    }
}

#endif
